name: Test and Analyze with Triggers and SonarCloud
description: Run node tests based on triggers, optional SonarCloud
branding:
  icon: check-square
  color: blue

inputs:
  ### Required
  commands:
    description: Commands to run tests, start with '|' for multi-line
    required: true

  dir:
    description: App/package directory
    required: true

  node_version:
    description: Node version to use (e.g., '22')
    required: true

  ### Typical / recommended
  cache:
    description: Package manager for caching; e.g. npm, yarn, pnpm
    default: npm

  sonar_args:
    # https://docs.sonarcloud.io/advanced-setup/analysis-parameters/
    description: SonarCloud command line arguments
    default: |
      -Dsonar.organization=bcgov-sonarcloud
      -Dsonar.projectKey=bcgov_${{ github.repository }}

  sonar_token:
    description: Sonar token, provide unpopulated token for pre-setup (will skip)

  triggers:
    description: Paths (array) used to trigger a build; e.g. ('./backend/' './frontend/)

  supply_scan:
    description: Enable supply chain attack detection using @aikidosec/safe-chain
    default: "true"

  dep_scan:
    description: "Enable dependency and export analysis using Knip for JS/TS projects. Options: off (skip), warn (run but don't fail, default), error (run and fail on issues)"
    default: "warn"

  knip_config:
    description: "Path to custom Knip configuration file (relative to workspace root). If not provided, uses action's default configuration"
    default: ""

  ### Usually a bad idea / not recommended
  diff_branch:
    description: Branch to diff against
    default: ${{ github.event.repository.default_branch }}

  repository:
    description: Non-default repository to clone (used for testing this action)
    default: ${{ github.repository }}

  branch:
    description: Non-default branch to clone (used for testing this action)
    default: ""

outputs:
  triggered:
    description: Whether the action was triggered based on path changes
    value: ${{ steps.diff.outputs.triggered }}

runs:
  using: composite
  steps:
    - name: Warnings for breaking changes
      shell: bash
      run: |
        # Warnings for breaking changes
        if [ ! -z "${{ inputs.sonar_project_token }}" ]; then
          echo -e "\nâš ï¸  Breaking change: sonar_project_token renamed"
          echo -e "\n\tAction: rename sonar_project_token to sonar_token\n"
          exit 1
        fi

        if [ ! -z "${{ inputs.sonar_comment_token }}" ]; then
          echo -e "\nâš ï¸  Breaking change: sonar_comment_token deprecated"
          echo -e "\n\tAction: remove sonar_comment_token parameter\n"
          exit 1
        fi

    # Send triggers to diff action, but only for pull requests
    - id: diff
      uses: bcgov/action-diff-triggers@0d193029efd26c76aeacaa84aba3328de8198370 # v0.2.0
      with:
        triggers: ${{ github.event_name == 'pull_request' && inputs.triggers || '' }}
        diff_branch: ${{ inputs.diff_branch }}

    # Get action repository and ref from environment variables with fallbacks
    - name: Get action repo and ref
      if: steps.diff.outputs.triggered == 'true'
      id: action_repo
      shell: bash
      run: |
        ACTION_REF="${GITHUB_ACTION_REF:-${{ github.action_ref }}}"

        # If still empty, extract from action_path (e.g., _actions/bcgov/action-test-and-analyse/temporary-branch/...)
        if [ -z "$ACTION_REF" ]; then
          if [[ "${{ github.action_path }}" =~ _actions/[^/]+/[^/]+/(.+) ]]; then
            ACTION_REF="${BASH_REMATCH[1]}"
            echo "Extracted ref from action_path: $ACTION_REF"
          else
            echo "::error::Could not determine action ref. action_path: ${{ github.action_path }}"
            exit 1
          fi
        fi

        echo "ref=$ACTION_REF" >> $GITHUB_OUTPUT
        echo "Using ref: $ACTION_REF"

    # Checkout the action (upstream) repo
    - uses: actions/checkout@v6
      if: steps.diff.outputs.triggered == 'true'
      with:
        repository: bcgov/action-test-and-analyse
        ref: ${{ steps.action_repo.outputs.ref }}

    - if: steps.diff.outputs.triggered == 'true'
      id: versions
      shell: bash
      run: |
        # Get Action Node Version
        set -e

        NODE_VER=$(grep -o '"node":\s*"[^"]*"' package.json | grep -o '"[^"]*"' | tail -1 | sed 's/[">=]//g' | cut -d. -f1)
        echo "action_node_version=$NODE_VER" >> $GITHUB_OUTPUT

    # Setup node version (for tool installation, no cache yet - file doesn't exist)
    - uses: actions/setup-node@v6
      if: steps.diff.outputs.triggered == 'true'
      with:
        node-version: ${{ steps.versions.outputs.action_node_version }}

    - shell: bash
      run: |
        # Install dependencies and files
        set -e

        # Safe-chain
        SAFE_VER=$(node -p "require('./package-lock.json').packages['node_modules/@aikidosec/safe-chain'].version")
        npm install -g "@aikidosec/safe-chain@${SAFE_VER}"
        safe-chain setup-ci

        # Knip
        KNIP_VER=$(node -p "require('./package-lock.json').packages['node_modules/knip'].version")
        npm install -g "knip@${KNIP_VER}"
        mkdir -p "${{ runner.temp }}"
        cp .knip.json "${{ runner.temp }}/.knip.json"

    # Checkout the target repository - SonarCloud requires a full clone
    - uses: actions/checkout@v6
      if: steps.diff.outputs.triggered == 'true'
      with:
        repository: ${{ inputs.repository }}
        ref: ${{ inputs.branch }}
        fetch-depth: 0

    # Setup node with caching (now that package-lock.json exists)
    - uses: actions/setup-node@v6
      if: steps.diff.outputs.triggered == 'true'
      with:
        node-version: ${{ inputs.node_version }}
        cache: ${{ inputs.cache }}
        cache-dependency-path: ${{ inputs.dir }}/package-lock.json

    # Run tests, hopefully generating coverage for SonarCloud
    - if: steps.diff.outputs.triggered == 'true'
      shell: bash
      working-directory: ${{ inputs.dir }}
      run: ${{ inputs.commands }}

    ### Optional SonarCloud

    # If sonar_token
    - if: inputs.sonar_token && steps.diff.outputs.triggered == 'true'
      uses: SonarSource/sonarqube-scan-action@a31c9398be7ace6bbfaf30c0bd5d415f843d45e9 # v7.0.0
      env:
        SONAR_TOKEN: ${{ inputs.sonar_token }}
      with:
        projectBaseDir: ${{ inputs.dir }}
        args: >
          ${{ inputs.sonar_args }}

    # If triggered and (dep or supply) enabled: run analysis tools
    - if: steps.diff.outputs.triggered == 'true' && inputs.dep_scan != 'off'
      working-directory: ${{ inputs.dir }}
      shell: bash
      run: |
        # Run Knip for dependency and export analysis
        set -e

        # Clean up any previous Knip output files
        rm -f knip-output.json knip-error.log knip-summary.txt

        # Set config file (suppress hints when using default config)
        if [ -n "${{ inputs.knip_config }}" ]; then
          KNIP_CONFIG="--config=${{ github.workspace }}/${{ inputs.knip_config }}"
        else
          KNIP_CONFIG="--config=${{ runner.temp }}/.knip.json --no-config-hints"
        fi

        # Run knip with JSON output for annotations (stderr separate to avoid corrupting JSON)
        set +e
        DOTENV_CONFIG_QUIET=true knip --dependencies --exports --reporter json --no-progress ${KNIP_CONFIG} > knip-output.json 2> knip-error.log
        KNIP_EXIT_CODE=$?
        set -e

        # Check if JSON is in stderr instead of stdout (some Knip versions/plugins write JSON to stderr)
        # Also check if stdout has content but needs validation
        if [ -f knip-output.json ] && [ ! -s knip-output.json ] && [ -f knip-error.log ] && [ -s knip-error.log ]; then
          # stdout is empty, check if stderr has valid JSON
          if jq -e . knip-error.log >/dev/null 2>&1; then
            # JSON is in stderr, move it to stdout file
            mv knip-error.log knip-output.json
            touch knip-error.log
          fi
        elif [ -f knip-output.json ] && [ -s knip-output.json ]; then
          # stdout has content, ensure it's valid JSON (strip whitespace if needed)
          if ! jq -e . knip-output.json >/dev/null 2>&1; then
            # Try stripping whitespace and validating - preserve original if cleanup fails
            if jq -e . knip-output.json > knip-output-trimmed.json 2>/dev/null; then
              mv knip-output-trimmed.json knip-output.json
            else
              rm -f knip-output-trimmed.json
              # JSON is invalid, but don't fail yet - let validation below handle it
            fi
          fi
        fi

        # Validate JSON before parsing (in case of non-JSON errors)
        # Only treat as hard failure when exit code is 2 (actual crash), not 1 (issues found)
        if [ "$KNIP_EXIT_CODE" -eq 2 ] && [ -f knip-output.json ]; then
          if ! jq -e . knip-output.json >/dev/null 2>&1; then
            # Add summary for invalid JSON before exiting
            {
              echo "## âŒ Knip Tool Failure (Invalid JSON Output)"
              echo ""
              echo "Knip exited with code $KNIP_EXIT_CODE and produced output that is not valid JSON."
              echo "This indicates a tool failure rather than analysis results."
              echo ""

              if [ -f knip-error.log ] && [ -s knip-error.log ]; then
                echo "### Error Output"
                echo "\`\`\`"
                cat knip-error.log
                echo "\`\`\`"
              fi
            } >> "$GITHUB_STEP_SUMMARY"
            
            echo "::error::Knip failed with exit code $KNIP_EXIT_CODE and did not produce valid JSON"
            if [ -f knip-error.log ] && [ -s knip-error.log ]; then
              cat knip-error.log
            fi
            exit $KNIP_EXIT_CODE
          fi
        fi

        # Parse JSON and create annotations
        # Validate JSON - try multiple approaches to handle edge cases
        JSON_VALID=false
        if [ -f knip-output.json ] && [ -s knip-output.json ]; then
          # Try standard validation first
          if jq -e . knip-output.json >/dev/null 2>&1; then
            JSON_VALID=true
          else
            # Try reading via stdin (handles BOM, encoding issues, etc.)
            if jq -e . < knip-output.json >/dev/null 2>&1; then
              # JSON is valid when read via stdin, rewrite it cleanly
              if jq -e . < knip-output.json > knip-output-clean.json 2>/dev/null; then
                mv knip-output-clean.json knip-output.json
                JSON_VALID=true
              else
                rm -f knip-output-clean.json
              fi
            fi
          fi
        fi

        if [ "$JSON_VALID" = "true" ]; then
          # Count issues
          UNUSED_FILES=$(jq -r '.files | length // 0' knip-output.json)
          
          # Count dependencies and exports across all issues
          UNUSED_DEPS=$(jq -r '[.issues[].dependencies[]?] | length' knip-output.json)
          UNUSED_DEV_DEPS=$(jq -r '[.issues[].devDependencies[]?] | length' knip-output.json)
          UNUSED_EXPORTS=$(jq -r '[.issues[].exports[]?] | length' knip-output.json)
          
          if [ "$UNUSED_FILES" -ne 0 ] || [ "$UNUSED_DEPS" -ne 0 ] || [ "$UNUSED_DEV_DEPS" -ne 0 ] || [ "$UNUSED_EXPORTS" -ne 0 ]; then
            
            # Create annotations for unused files
            if [ "$UNUSED_FILES" -ne 0 ]; then
              jq -r --arg dir "${{ inputs.dir }}" '.files[]? | "::warning file=\($dir + "/" + .),line=1::Unused file"' knip-output.json
            fi
            # Create annotations for unused dependencies
            if [ "$UNUSED_DEPS" -ne 0 ]; then
              jq -r --arg dir "${{ inputs.dir }}" '.issues[]? | select(.dependencies != null and (.dependencies | length) > 0) | . as $issue | $issue.dependencies[]? | "::warning file=\($dir + "/" + ($issue.file // "package.json")),line=\(.line // 1)::Unused dependency: \(.name)"' knip-output.json
            fi
            
            # Create annotations for unused devDependencies
            if [ "$UNUSED_DEV_DEPS" -ne 0 ]; then
              jq -r --arg dir "${{ inputs.dir }}" '.issues[]? | select(.devDependencies != null and (.devDependencies | length) > 0) | . as $issue | $issue.devDependencies[]? | "::warning file=\($dir + "/" + ($issue.file // "package.json")),line=\(.line // 1)::Unused devDependency: \(.name)"' knip-output.json
            fi
            
            # Create annotations for unused exports
            if [ "$UNUSED_EXPORTS" -ne 0 ]; then
              jq -r --arg dir "${{ inputs.dir }}" '.issues[]? | select(.exports != null and (.exports | length) > 0) | . as $issue | $issue.exports[]? | "::notice file=\($dir + "/" + ($issue.file // "package.json")),line=\(.line // 1)::Unused export: \(.name)"' knip-output.json
            fi
          fi
          
          # Run knip with default output for detailed summary (when issues found)
          # Build config (suppress hints when using default config, same as JSON run)
          if [ -n "${{ inputs.knip_config }}" ]; then
            SUMMARY_CONFIG="--config=${{ github.workspace }}/${{ inputs.knip_config }}"
          else
            SUMMARY_CONFIG="--config=${{ runner.temp }}/.knip.json --no-config-hints"
          fi
          
          # Capture detailed output for summary when issues are found (any count > 0)
          # Always generate summary output to show full details including unresolved imports, config hints, etc.
          if [ "$UNUSED_FILES" -ne 0 ] || [ "$UNUSED_DEPS" -ne 0 ] || [ "$UNUSED_DEV_DEPS" -ne 0 ] || [ "$UNUSED_EXPORTS" -ne 0 ] || [ $KNIP_EXIT_CODE -ne 0 ]; then
            set +e
            knip --dependencies --exports ${SUMMARY_CONFIG} > knip-summary.txt 2>&1
            set -e
          fi
          
          # Add summary to step summary (always show when JSON is valid, even when no issues)
          {
            echo "## ðŸ” Knip Analysis Results"
            echo ""
            
            # Summary counts
            echo "| Category | Count |"
            echo "|----------|-------|"
            echo "| Unused files | $UNUSED_FILES |"
            echo "| Unused dependencies | $UNUSED_DEPS |"
            echo "| Unused devDependencies | $UNUSED_DEV_DEPS |"
            echo "| Unused exports | $UNUSED_EXPORTS |"
            echo ""
            
            # Full detailed output with hints (strip ANSI escape codes) - show when summary file exists
            if [ -f knip-summary.txt ] && [ -s knip-summary.txt ]; then
              echo "### ðŸ“‹ Full Output"
              echo "\`\`\`"
              sed 's/\x1b\[[0-9;]*[a-zA-Z]//g' knip-summary.txt
              echo "\`\`\`"
              echo ""
            fi
            
            if [ $KNIP_EXIT_CODE -ne 0 ]; then
              echo "âš ï¸ **Issues found** - See annotations in the Checks tab for details"
            else
              echo "âœ… **No issues found**"
            fi
          } >> "$GITHUB_STEP_SUMMARY"
        fi

        # Handle result
        # Use the JSON_VALID flag we set above
        HAS_VALID_JSON=$JSON_VALID

        if [ $KNIP_EXIT_CODE -eq 0 ]; then
          echo "âœ… Knip analysis complete - no unused dependencies or exports found"
        elif [ "$HAS_VALID_JSON" = "true" ]; then
          # Valid JSON with non-zero exit = analysis found issues (respect warn/error mode)
          echo "âš ï¸  Knip found issues"
          if [ "${{ inputs.dep_scan }}" = "warn" ]; then
            echo "Running in warn mode - workflow will continue"
            exit 0
          else
            echo "Running in error mode - workflow will exit"
            exit $KNIP_EXIT_CODE
          fi
        elif [ $KNIP_EXIT_CODE -eq 1 ]; then
          # Exit code 1 + invalid JSON = issues found but output corrupted/unparseable
          # Still respect warn/error mode (stop hard in error mode)
          {
            echo "## âš ï¸ Knip Found Issues (Output Corrupted)"
            echo ""
            echo "Knip reported issues (exit code 1) but the output could not be parsed as JSON."
            echo "This may indicate plugin output mixed with JSON or other output issues."
            echo ""
            if [ -f knip-error.log ] && [ -s knip-error.log ]; then
              echo "### Error Output"
              echo "\`\`\`"
              cat knip-error.log
              echo "\`\`\`"
            fi
            if [ -f knip-output.json ] && [ -s knip-output.json ]; then
              echo "### Output File"
              echo "\`\`\`"
              cat knip-output.json
              echo "\`\`\`"
            fi
          } >> "$GITHUB_STEP_SUMMARY"

          echo "âš ï¸  Knip found issues but output was corrupted/unparseable"
          if [ "${{ inputs.dep_scan }}" = "warn" ]; then
            echo "Running in warn mode - workflow will continue"
            exit 0
          else
            echo "Running in error mode - workflow will exit"
            exit $KNIP_EXIT_CODE
          fi
        else
          # Exit code 2+ = actual tool failure (warn but continue)
          {
            echo "## âŒ Knip Tool Failure"
            echo ""
            echo "Knip was unable to complete the analysis. This indicates a tool failure, not analysis results."
            echo ""
            if [ -f knip-error.log ] && [ -s knip-error.log ]; then
              echo "### Error Output"
              echo "\`\`\`"
              cat knip-error.log
              echo "\`\`\`"
            fi
          } >> "$GITHUB_STEP_SUMMARY"
          
          echo "::warning::Knip tool failure - unable to complete analysis (workflow will continue)"
          if [ -f knip-error.log ] && [ -s knip-error.log ]; then
            echo "Error output:"
            cat knip-error.log
          fi
        fi

    # Fix - Clone for action.yml and other verifications
    - name: Checkout Action repo to pass tests
      if: always() && inputs.repository != github.repository
      uses: actions/checkout@v6
