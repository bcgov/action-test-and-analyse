name: Test and Analyze with Triggers and SonarCloud
description: Run node tests based on triggers, optional SonarCloud
branding:
  icon: check-square
  color: blue

inputs:
  ### Required
  commands:
    description: Commands to run tests, start with '|' for multi-line
    required: true

  dir:
    description: App/package directory
    required: true

  node_version:
    description: Node version to use (e.g., '22')
    required: true

  ### Typical / recommended
  cache:
    description: Package manager for caching; e.g. npm, yarn, pnpm
    default: npm

  sonar_args:
    # https://docs.sonarcloud.io/advanced-setup/analysis-parameters/
    description: SonarCloud command line arguments
    default: |
      -Dsonar.organization=bcgov-sonarcloud
      -Dsonar.projectKey=bcgov_${{ github.repository }}

  sonar_token:
    description: Sonar token, provide unpopulated token for pre-setup (will skip)

  triggers:
    description: Paths (array) used to trigger a build; e.g. ('./backend/' './frontend/)

  supply_scan:
    description: Enable supply chain attack detection using @aikidosec/safe-chain
    default: "true"

  dep_scan:
    description: "Enable dependency and export analysis using Knip for JS/TS projects. Options: off (skip), warn (run but don't fail, default), error (run and fail on issues)"
    default: "warn"

  knip_config:
    description: "Path to custom Knip configuration file (relative to workspace root). If not provided, uses action's default configuration"
    default: ""

  ### Usually a bad idea / not recommended
  diff_branch:
    description: Branch to diff against
    default: ${{ github.event.repository.default_branch }}

  repository:
    description: Non-default repository to clone (used for testing this action)
    default: ${{ github.repository }}

  branch:
    description: Non-default branch to clone (used for testing this action)
    default: ""

outputs:
  triggered:
    description: Whether the action was triggered based on path changes
    value: ${{ steps.diff.outputs.triggered }}

runs:
  using: composite
  steps:
    - name: Warnings for breaking changes
      shell: bash
      run: |
        # Warnings for breaking changes
        if [ ! -z "${{ inputs.sonar_project_token }}" ]; then
          echo -e "\n‚ö†Ô∏è  Breaking change: sonar_project_token renamed"
          echo -e "\n\tAction: rename sonar_project_token to sonar_token\n"
          exit 1
        fi

        if [ ! -z "${{ inputs.sonar_comment_token }}" ]; then
          echo -e "\n‚ö†Ô∏è  Breaking change: sonar_comment_token deprecated"
          echo -e "\n\tAction: remove sonar_comment_token parameter\n"
          exit 1
        fi

    # Send triggers to diff action (only for pull requests; omitted for push events so tests always run)
    - id: diff
      uses: bcgov/action-diff-triggers@a4753d53614cac4eb417cd35b05e0e401a76fc9d # v1.0.0
      with:
        triggers: ${{ github.event_name == 'pull_request' && inputs.triggers || '' }}
        ref: ${{ inputs.diff_branch }}

    # Get action repository and ref from environment variables with fallbacks
    - name: Get action repo and ref
      if: steps.diff.outputs.triggered == 'true'
      id: action_repo
      shell: bash
      run: |
        ACTION_REF="${GITHUB_ACTION_REF:-${{ github.action_ref }}}"

        # If still empty, extract from action_path (e.g., _actions/bcgov/action-test-and-analyse/temporary-branch/...)
        if [ -z "$ACTION_REF" ]; then
          if [[ "${{ github.action_path }}" =~ _actions/[^/]+/[^/]+/(.+) ]]; then
            ACTION_REF="${BASH_REMATCH[1]}"
          else
            echo "::error::Could not determine action ref. action_path: ${{ github.action_path }}"
            exit 1
          fi
        fi

        echo "ref=$ACTION_REF" >> $GITHUB_OUTPUT
        echo "Using ref: $ACTION_REF"

    # Checkout the action (upstream) repo
    - uses: actions/checkout@v6
      if: steps.diff.outputs.triggered == 'true'
      with:
        repository: bcgov/action-test-and-analyse
        ref: ${{ steps.action_repo.outputs.ref }}

    - if: steps.diff.outputs.triggered == 'true'
      id: versions
      shell: bash
      run: |
        # Get Action Node Version
        set -e

        NODE_VER=$(grep -o '"node":\s*"[^"]*"' package.json | grep -o '"[^"]*"' | tail -1 | sed 's/[">=]//g' | cut -d. -f1)
        echo "action_node_version=$NODE_VER" >> $GITHUB_OUTPUT

    # Setup node version (for tool installation, no cache yet - file doesn't exist)
    - uses: actions/setup-node@v6
      if: steps.diff.outputs.triggered == 'true'
      with:
        node-version: ${{ steps.versions.outputs.action_node_version }}

    - shell: bash
      if: steps.diff.outputs.triggered == 'true'
      run: |
        # Install dependencies and files
        set -e

        # Safe-chain
        SAFE_VER=$(node -p "require('./package-lock.json').packages['node_modules/@aikidosec/safe-chain'].version")
        npm install -g "@aikidosec/safe-chain@${SAFE_VER}"
        safe-chain setup-ci

        # Knip
        KNIP_VER=$(node -p "require('./package-lock.json').packages['node_modules/knip'].version")
        npm install -g "knip@${KNIP_VER}"
        mkdir -p "${{ runner.temp }}"
        cp .knip.json "${{ runner.temp }}/.knip.json"

    # Checkout the target repository - SonarCloud requires a full clone
    - uses: actions/checkout@v6
      if: steps.diff.outputs.triggered == 'true'
      with:
        repository: ${{ inputs.repository }}
        ref: ${{ inputs.branch }}
        fetch-depth: 0

    # Setup node with caching (now that package-lock.json exists)
    - uses: actions/setup-node@v6
      if: steps.diff.outputs.triggered == 'true'
      with:
        node-version: ${{ inputs.node_version }}
        cache: ${{ inputs.cache }}
        cache-dependency-path: ${{ inputs.dir }}/package-lock.json

    # Run tests, hopefully generating coverage for SonarCloud
    - if: steps.diff.outputs.triggered == 'true'
      shell: bash
      working-directory: ${{ inputs.dir }}
      run: ${{ inputs.commands }}

    ### Optional SonarCloud

    # If sonar_token
    - if: inputs.sonar_token && steps.diff.outputs.triggered == 'true'
      uses: SonarSource/sonarqube-scan-action@a31c9398be7ace6bbfaf30c0bd5d415f843d45e9 # v7.0.0
      env:
        SONAR_TOKEN: ${{ inputs.sonar_token }}
      with:
        projectBaseDir: ${{ inputs.dir }}
        args: >
          ${{ inputs.sonar_args }}

    # If triggered and (dep or supply) enabled: run analysis tools
    - if: steps.diff.outputs.triggered == 'true' && inputs.dep_scan != 'off'
      working-directory: ${{ inputs.dir }}
      shell: bash
      run: |
        # Run Knip for dependency and export analysis
        set -e

        # Clean up any previous Knip output files
        rm -f knip-output.json knip-summary.txt

        # Set config file (suppress hints when using default config)
        if [ -n "${{ inputs.knip_config }}" ]; then
          KNIP_CONFIG="--config=${{ github.workspace }}/${{ inputs.knip_config }}"
        else
          KNIP_CONFIG="--config=${{ runner.temp }}/.knip.json --no-config-hints"
        fi

        # Run knip with JSON output for annotations
        set +e
        DOTENV_CONFIG_QUIET=true knip --dependencies --exports --reporter json --no-progress ${KNIP_CONFIG} > knip-output.json
        KNIP_EXIT_CODE=$?
        set -e

        # Parse JSON and create annotations using Node.js
        if [ -f knip-output.json ] && [ -s knip-output.json ]; then
          # Set directory as environment variable for safe passing to Node.js
          export KNIP_DIR="${{ inputs.dir }}"
          
          # Validate and parse JSON with error handling
          if ! PARSE_ERROR=$(node -e "
            try {
              const fs = require('fs');
              const content = fs.readFileSync('./knip-output.json', 'utf8');
              if (!content.trim()) {
                console.error('ERROR_EMPTY');
                process.exit(1);
              }
              const data = JSON.parse(content);
              if (!data || typeof data !== 'object') {
                console.error('ERROR_INVALID');
                process.exit(1);
              }
              console.log('OK');
            } catch (error) {
              if (error.code === 'ENOENT') {
                console.error('ERROR_NOT_FOUND');
              } else if (error instanceof SyntaxError) {
                console.error('ERROR_INVALID_JSON: ' + error.message);
              } else {
                console.error('ERROR_PARSE: ' + error.message);
              }
              process.exit(1);
            }
          " 2>&1); then
          
            echo "::error::Failed to parse Knip JSON output"
            case "$PARSE_ERROR" in
              *ERROR_NOT_FOUND*)
                echo "::error::knip-output.json file not found. Knip may have failed to generate output."
                ;;
              *ERROR_EMPTY*)
                echo "::error::knip-output.json file is empty. Knip may have produced no output."
                ;;
              *ERROR_INVALID_JSON*)
                echo "::error::Invalid JSON format in knip-output.json. Check if Knip produced error output."
                echo "::error::$PARSE_ERROR"
                ;;
              *)
                echo "::error::JSON parsing failed: $PARSE_ERROR"
                ;;
            esac
            echo "‚ö†Ô∏è  Skipping Knip analysis due to JSON parsing error"
            exit 0
          fi
          
          # Count issues using Node.js with error handling
          set +e
          UNUSED_FILES=$(node -e "
            try {
              const data = require('./knip-output.json');
              console.log((data.files || []).length);
            } catch (error) {
              console.error('::error::Failed to parse files from Knip output: ' + error.message);
              process.exit(1);
            }
          " 2>&1)
          if [ $? -ne 0 ]; then
            echo "::error::Failed to count unused files"
            UNUSED_FILES=0
          fi
          
          UNUSED_DEPS=$(node -e "
            try {
              const data = require('./knip-output.json');
              console.log((data.issues || []).flatMap(i => i.dependencies || []).length);
            } catch (error) {
              console.error('::error::Failed to parse dependencies from Knip output: ' + error.message);
              process.exit(1);
            }
          " 2>&1)
          if [ $? -ne 0 ]; then
            echo "::error::Failed to count unused dependencies"
            UNUSED_DEPS=0
          fi
          
          UNUSED_DEV_DEPS=$(node -e "
            try {
              const data = require('./knip-output.json');
              console.log((data.issues || []).flatMap(i => i.devDependencies || []).length);
            } catch (error) {
              console.error('::error::Failed to parse devDependencies from Knip output: ' + error.message);
              process.exit(1);
            }
          " 2>&1)
          if [ $? -ne 0 ]; then
            echo "::error::Failed to count unused devDependencies"
            UNUSED_DEV_DEPS=0
          fi
          
          UNUSED_EXPORTS=$(node -e "
            try {
              const data = require('./knip-output.json');
              console.log((data.issues || []).flatMap(i => i.exports || []).length);
            } catch (error) {
              console.error('::error::Failed to parse exports from Knip output: ' + error.message);
              process.exit(1);
            }
          " 2>&1)
          if [ $? -ne 0 ]; then
            echo "::error::Failed to count unused exports"
            UNUSED_EXPORTS=0
          fi
          set -e
            
          if [ "$UNUSED_FILES" -ne 0 ] || [ "$UNUSED_DEPS" -ne 0 ] || [ "$UNUSED_DEV_DEPS" -ne 0 ] || [ "$UNUSED_EXPORTS" -ne 0 ]; then
            
            # Create annotations for unused files
            if [ "$UNUSED_FILES" -ne 0 ]; then
              node -e "
                try {
                  const data = require('./knip-output.json');
                  const dir = process.env.KNIP_DIR;
                  (data.files || []).forEach(file => console.log(\`::warning file=\${dir}/\${file},line=1::Unused file\`));
                } catch (error) {
                  console.error('::error::Failed to create file annotations: ' + error.message);
                  process.exit(1);
                }
              " || echo "::warning::Failed to create annotations for unused files"
            fi
            # Create annotations for unused dependencies
            if [ "$UNUSED_DEPS" -ne 0 ]; then
              node -e "
                try {
                  const data = require('./knip-output.json');
                  const dir = process.env.KNIP_DIR;
                  (data.issues || []).forEach(issue => {
                    (issue.dependencies || []).forEach(dep => console.log(\`::warning file=\${dir}/\${issue.file || 'package.json'},line=\${dep.line || 1}::Unused dependency: \${dep.name}\`));
                  });
                } catch (error) {
                  console.error('::error::Failed to create dependency annotations: ' + error.message);
                  process.exit(1);
                }
              " || echo "::warning::Failed to create annotations for unused dependencies"
            fi
            
            # Create annotations for unused devDependencies
            if [ "$UNUSED_DEV_DEPS" -ne 0 ]; then
              node -e "
                try {
                  const data = require('./knip-output.json');
                  const dir = process.env.KNIP_DIR;
                  (data.issues || []).forEach(issue => {
                    (issue.devDependencies || []).forEach(dep => console.log(\`::warning file=\${dir}/\${issue.file || 'package.json'},line=\${dep.line || 1}::Unused devDependency: \${dep.name}\`));
                  });
                } catch (error) {
                  console.error('::error::Failed to create devDependency annotations: ' + error.message);
                  process.exit(1);
                }
              " || echo "::warning::Failed to create annotations for unused devDependencies"
            fi
            
            # Create annotations for unused exports
            if [ "$UNUSED_EXPORTS" -ne 0 ]; then
              node -e "
                try {
                  const data = require('./knip-output.json');
                  const dir = process.env.KNIP_DIR;
                  (data.issues || []).forEach(issue => {
                    (issue.exports || []).forEach(exp => console.log(\`::notice file=\${dir}/\${issue.file || 'package.json'},line=\${exp.line || 1}::Unused export: \${exp.name}\`));
                  });
                } catch (error) {
                  console.error('::error::Failed to create export annotations: ' + error.message);
                  process.exit(1);
                }
              " || echo "::warning::Failed to create annotations for unused exports"
            fi
          fi
            
          # Run knip with default output for detailed summary (only when issues found)
          # Build config (suppress hints when using default config, same as JSON run)
          if [ -n "${{ inputs.knip_config }}" ]; then
            SUMMARY_CONFIG="--config=${{ github.workspace }}/${{ inputs.knip_config }}"
          else
            SUMMARY_CONFIG="--config=${{ runner.temp }}/.knip.json --no-config-hints"
          fi
          
          # Capture detailed output for summary only when issues were found
          if [ $KNIP_EXIT_CODE -ne 0 ]; then
            set +e
            knip --dependencies --exports ${SUMMARY_CONFIG} > knip-summary.txt 2>&1
            set -e
          fi
          # Add summary to step summary
          {
            echo "## üîç Knip Analysis Results"
            echo ""
            
            # Summary counts
            echo "| Category | Count |"
            echo "|----------|-------|"
            echo "| Unused files | $UNUSED_FILES |"
            echo "| Unused dependencies | $UNUSED_DEPS |"
            echo "| Unused devDependencies | $UNUSED_DEV_DEPS |"
            echo "| Unused exports | $UNUSED_EXPORTS |"
            echo ""
            
            # Full detailed output with hints (strip ANSI escape codes) - only when generated
            if [ -f knip-summary.txt ]; then
              echo "### üìã Full Output"
              echo "\`\`\`"
              sed 's/\x1b\[[0-9;]*[a-zA-Z]//g' knip-summary.txt
              echo "\`\`\`"
              echo ""
            fi
            
            if [ $KNIP_EXIT_CODE -ne 0 ]; then
              echo "‚ö†Ô∏è **Issues found** - See annotations in the Checks tab for details"
            else
              echo "‚úÖ **No issues found**"
            fi
          } >> "$GITHUB_STEP_SUMMARY"
        fi

        # Handle result
        if [ $KNIP_EXIT_CODE -eq 0 ]; then
          echo "‚úÖ Knip analysis complete - no unused dependencies or exports found"
        else
          # Non-zero exit = analysis found issues (respect warn/error mode)
          echo "‚ö†Ô∏è  Knip found issues"
          if [ "${{ inputs.dep_scan }}" = "warn" ]; then
            echo "Running in warn mode - workflow will continue"
            exit 0
          else
            echo "Running in error mode - workflow will exit"
            exit $KNIP_EXIT_CODE
          fi
        fi

    # Fix - Clone for action.yml and other verifications
    - name: Checkout Action repo to pass tests
      if: always() && inputs.repository != github.repository
      uses: actions/checkout@v6
